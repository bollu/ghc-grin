/*
  HINT: is interpreted -/+

  primop effectful
    + "catch#"                 :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> (%b -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "raise#"                 :: %b -> %o
    + "raiseIO#"               :: %a -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %b}
    + "maskAsyncExceptions#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "maskUninterruptible#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "unmaskAsyncExceptions#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    - "getMaskingState#"       :: {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" T_Int64}
*/

/*
  NOTES for higher order primop support:
    the higher order primops execute function calls and also pass the arguments
    this mean that they have to collect the arguments somewhere, maybe from an accompaning other primop provides it,
    i.e. raise provides the arguments for catch

*/
// SECTION: higher order primop evaluator

.decl RaisedEx(f:Variable)
.output RaisedEx

// "raise#"   :: %b -> %o
// "raiseIO#" :: %a -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %b}
// collect raised exceptions
RaisedEx(ex) :-
  REACHABLE(r)
  (Call(r, "raise#", _) ; Call(r, "raiseIO#", _)),
  CallArgument(r, 0, ex).

// "catch#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//          -> (%b -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//          -> {"State#" {RealWorld}}
//          -> {"GHC.Prim.Unit#" %a}
// handle the wrapped function
TypeVarPointsTo(r, ty_res_value, fun_ret),  // handle return value
CallPNode1(r, v0, v2_state) :-
  REACHABLE(r)
  Call(r, "catch#", _),
  // wrapped fun
  CallArgument(r, 0, v0),
  PNode(v0, fun, _, 1),
  // state
  CallArgument(r, 2, v2_state),
  // return value
  RetTup1Node0("catch#", ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun, fun_ret).

// NOTE: the handler has its own rule, because it fires only when there are exceptions, while the wrapped function is always called
// handle ex-handler
TypeVarPointsTo(r, ty_res_value, handler_ret),     // handle return value
CallPNode2(r, v1, ex, v2_state) :-
  REACHABLE(r)
  Call(r, "catch#", _),
  // handler
  CallArgument(r, 1, v1),
  // state
  CallArgument(r, 2, v2_state),
  PNode(v1, handler, _, 2),
  // exceptions
  RaisedEx(ex),
  // return value
  RetTup1Node0("catch#", ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(handler, handler_ret).

// "maskAsyncExceptions#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
// "maskUninterruptible#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
// "unmaskAsyncExceptions#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
TypeVarPointsTo(r, ty_res_value, fun_ret),  // handle return value
CallPNode1(r, v0, v1_state) :-
  REACHABLE(r)
  ( op = "maskAsyncExceptions#"
  ; op = "maskUninterruptible#"
  ; op = "unmaskAsyncExceptions#"
  ),
  Call(r, op, _),
  // pass argument to the wrapped function
  CallArgument(r, 0, v0),
  PNode(v0, fun, _, 1),
  CallArgument(r, 1, v1_state),
  // return value
  RetTup1Node0(op, ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun, fun_ret).
