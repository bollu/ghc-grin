/*
  HINT: is interpreted -/+

  primop effectful
    + "atomically#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    - "retry#"      :: {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "catchRetry#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "catchSTM#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> (%b -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "newTVar#"    :: %a -> {"State#" %s} -> {"GHC.Prim.Unit#" {"TVar#" %s %a}}
    + "readTVar#"   :: {"TVar#" %s %a} -> {"State#" %s} -> {"GHC.Prim.Unit#" %a}
    + "readTVarIO#" :: {"TVar#" %s %a} -> {"State#" %s} -> {"GHC.Prim.Unit#" %a}
    + "writeTVar#"  :: {"TVar#" %s %a} -> %a -> {"State#" %s} -> {"GHC.Prim.(##)"}

  primop pure
    - "sameTVar#" :: {"TVar#" %s %a} -> {"TVar#" %s %a} -> T_Int64
*/

.decl TVar(ext_result:Variable, ty_node:Variable, item:Variable)
.output TVar

// "atomically#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
TypeVarPointsTo(r, ty_res_value, fun_ret),  // handle return value
CallPNode1(r, v0, v1_state) :-
  op = "atomically#",
  REACHABLE(r)
  Call(r, op, _),
  // pass argument to the wrapped function
  CallArgument(r, 0, v0),
  PNode(v0, fun, _, 1),
  CallArgument(r, 1, v1_state),
  // return value
  RetTup1Node0(op, ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun, fun_ret).

// "catchRetry#"  :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//                -> ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//                -> {"State#" {RealWorld}}
//                -> {"GHC.Prim.Unit#" %a}
TypeVarPointsTo(r, ty_res_value, fun0_ret),  // handle return value
TypeVarPointsTo(r, ty_res_value, fun1_ret),  // handle return value
CallPNode1(r, v0, v2_state),
CallPNode1(r, v1, v2_state) :-
  op = "catchRetry#",
  REACHABLE(r)
  Call(r, op, _),
  // pass argument to the wrapped function
  // first function
  CallArgument(r, 0, v0),
  PNode(v0, fun0, _, 1),
  // second function
  CallArgument(r, 1, v1),
  PNode(v1, fun1, _, 1),
  // state
  CallArgument(r, 2, v2_state),
  // return value
  RetTup1Node0(op, ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun0, fun0_ret),
  ReturnValue(fun1, fun1_ret).

// "catchSTM#"  :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//              -> (%b -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//              -> {"State#" {RealWorld}}
//              -> {"GHC.Prim.Unit#" %a}
// handle the wrapped function
TypeVarPointsTo(r, ty_res_value, fun_ret),  // handle return value
CallPNode1(r, v0, v2_state) :-
  REACHABLE(r)
  Call(r, "catchSTM#", _),
  // pass argument to the wrapped function
  CallArgument(r, 0, v0),
  PNode(v0, fun, _, 1),
  CallArgument(r, 2, v2_state),
  // return value
  RetTup1Node0("catchSTM#", ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun, fun_ret).

// NOTE: the handler has its own rule, because it fires only when there are exceptions, while the wrapped function is always called
// handle ex-handler
TypeVarPointsTo(r, ty_res_value, handler_ret),     // handle return value
CallPNode2(r, v1, ex, v2_state) :-
  REACHABLE(r)
  Call(r, "catchSTM#", _),
  // pass argument to the handler function
  CallArgument(r, 1, v1),
  CallArgument(r, 2, v2_state),
  PNode(v1, handler, _, 2),
  RaisedEx(ex),
  // return value
  RetTup1Node0("catchSTM#", ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(handler, handler_ret).

// "newTVar#" :: %a -> {"State#" %s} -> {"GHC.Prim.Unit#" {"TVar#" %s %a}}
// new array
TVar(r, ty_node, item) :-
  op = "newTVar#",
  REACHABLE(r)
  Call(r, op, _),
  // initial item
  CallArgument(r, 0, item),
  // extract result node
  RetTup1Node0(op, ty_node).

// "readTVar#"   :: {"TVar#" %s %a} -> {"State#" %s} -> {"GHC.Prim.Unit#" %a}
// "readTVarIO#" :: {"TVar#" %s %a} -> {"State#" %s} -> {"GHC.Prim.Unit#" %a}
TypeVarPointsTo(r, ty_node, item) :-
  (op = "readTVar#" ; op = "readTVarIO#"),
  REACHABLE(r)
  Call(r, op, _),
  // lookup array items
  CallArgument(r, 0, arr),
  ExternalOrigin(arr, ext_result, arr_node),
  TVar(ext_result, arr_node, item),
  // lookup result node
  RetTup1Node0(op, ty_node).

// "writeTVar#"  :: {"TVar#" %s %a} -> %a -> {"State#" %s} -> {"GHC.Prim.(##)"}
// extend array
TVar(ext_result, ty_node, item) :-
  op = "writeTVar#",
  REACHABLE(r)
  Call(r, op, _),
  // item to write
  CallArgument(r, 1, item),
  // lookup array
  CallArgument(r, 0, arr),
  ExternalOrigin(arr, ext_result, ty_node),
  // validation
  TVar(ext_result, ty_node, _).
