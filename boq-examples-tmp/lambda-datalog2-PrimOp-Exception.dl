/*
  HINT: is interpreted -/+

  primop effectful
    + "catch#"                 :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> (%b -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "raise#"                 :: %b -> %o
    + "raiseIO#"               :: %a -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %b}
    + "maskAsyncExceptions#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "maskUninterruptible#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    + "unmaskAsyncExceptions#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
    - "getMaskingState#"       :: {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" T_Int64}
*/

/*
  NOTES for higher order primop support:
    the higher order primops execute function calls and also pass the arguments
    this mean that they have to collect the arguments somewhere, maybe from an accompaning other primop provides it,
    i.e. raise provides the arguments for catch

*/
// SECTION: higher order primop evaluator

.decl RaisedEx(f:Variable)
.output RaisedEx

// "raise#"   :: %b -> %o
// "raiseIO#" :: %a -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %b}
// collect raised exceptions
RaisedEx(ex) :-
  (Call(r, "raise#", _) ; Call(r, "raiseIO#", _)),
  CallArgument(r, 0, ex).

// "catch#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//          -> (%b -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a})
//          -> {"State#" {RealWorld}}
//          -> {"GHC.Prim.Unit#" %a}
// handle the wrapped function
Called(r, fun),
TypeVarPointsTo(r, ty_res_value, fun_ret),  // handle return value
PointsTo(fun_arg_0, v2) :-  // pass realworld
  Call(r, "catch#", _),
  // pass argument to the wrapped function
  CallArgument(r, 0, v0),
  PNode(v0, fun, fun_arity, 1),
  CodeParameter(fun, fun_arity-1, fun_arg_0),
  CallArgument(r, 2, v2),
  // return value
  RetTup1Node0("catch#", ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun, fun_ret).

// handle ex-handler
Called(r, handler),
TypeVarPointsTo(r, ty_res_value, handler_ret),     // handle return value
PointsTo(handler_arg_0, ex),  // pass exceptions
PointsTo(handler_arg_1, v2):- // pass realworld
  Call(r, "catch#", _),
  // pass argument to the handler function
  CallArgument(r, 1, v1),
  CallArgument(r, 2, v2),
  PNode(v1, handler, handler_arity, 2),
  CodeParameter(handler, handler_arity-2, handler_arg_0),
  CodeParameter(handler, handler_arity-1, handler_arg_1),
  RaisedEx(ex),
  // return value
  RetTup1Node0("catch#", ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(handler, handler_ret).

// "maskAsyncExceptions#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
// "maskUninterruptible#"   :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
// "unmaskAsyncExceptions#" :: ({"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}) -> {"State#" {RealWorld}} -> {"GHC.Prim.Unit#" %a}
Called(r, fun),
TypeVarPointsTo(r, ty_res_value, fun_ret),  // handle return value
PointsTo(fun_arg_0, v2_realworld) :-  // pass realworld
  ( op = "maskAsyncExceptions#"
  ; op = "maskUninterruptible#"
  ; op = "unmaskAsyncExceptions#"
  ),
  Call(r, op, _),
  // pass argument to the wrapped function
  CallArgument(r, 0, v0),
  PNode(v0, fun, fun_arity, 1),
  CodeParameter(fun, fun_arity-1, fun_arg_0),
  CallArgument(r, 1, v2_realworld),
  // return value
  RetTup1Node0(op, ty_res_value),
  IsTypeVariable(ty_res_value), // extra validation
  ReturnValue(fun, fun_ret).
