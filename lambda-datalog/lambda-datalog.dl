
.type Alternative
.type Closure
.type Function
.type Variable
.type Tag
.type CodeName = Function | Alternative | Closure
.type Mode // 'lazy' or 'strict'

// strictness context
.decl EvalMode(result:Variable, mode:Mode)

// variable
.decl Move(result:Variable, value:Variable)

// node value
.decl Node(result_node:Variable, t:Tag)
.decl NodeArgument(result_node:Variable, i:number, item:Variable)

// app a.k.a. call
.decl Call(call_result:Variable, f:Function)
.decl CallArgument(call_result:Variable, i:number, value:Variable)

// function
// example: f param0 param1 = ...
.decl FunctionParameter(f:Function, i:number, parameter:Variable)

// case + alt
.decl Case(case_result:Variable, scrutinee:Variable)
.decl Alt(case_result:Variable, alt_value:Variable, t:Tag)
.decl AltParameter(alt_value:Variable, i:number, parameter:Variable)

// closure
// example: \[captured0 captured1] param0 param1 = ...
.decl ClosureVariable(c:Closure, i:number, captured:Variable)
.decl ClosureParameter(c:Closure, i:number, parameter:Variable)

// return value
.decl ReturnValue(n:CodeName, value:Variable)

// instruction ordering
.decl FirstInst(n:CodeName, result:Variable)
.decl NextInst(prev:Variable, next:Variable)

// letrec
.decl RecGroup(first:Variable, v:Variable)

/*
  TODO:
    externals
*/

/*
GHC.Show.show v.s37198.0 =
  letS
    v.s37199.0 = v.s37198.0 @
    val.7158 = case v.s37199.0 of
      (GHC.Show.C:Show v.s37200.0 v.s37201.0 v.s37202.0) @ alt.3439 ->
          letS
            val.7159 = v.s37201.0 @
          val.7159
  val.7158
*/

