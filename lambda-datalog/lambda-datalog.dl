
.type External
.type Function
.type Variable
.type Tag
.type CodeName = Function | Variable | External
.type Mode  // 'lazy' or 'strict'
.type Eff   // 'pure' or 'effectful'

// strictness context
.decl EvalMode(result:Variable, mode:Mode)

// variable
.decl Move(result:Variable, value:Variable)

// node value
.decl Node(result_node:Variable, t:Tag)
.decl NodeArgument(result_node:Variable, i:number, item:Variable)

// app a.k.a. call
.decl Call(call_result:Variable, f:CodeName)
.decl CallArgument(call_result:Variable, i:number, value:Variable)

// function
// example: f param0 param1 = ...
.decl FunctionParameter(f:Function, i:number, parameter:Variable)

// case + alt
.decl Case(case_result:Variable, scrutinee:Variable)
.decl Alt(case_result:Variable, alt_value:Variable, t:Tag)
.decl AltParameter(alt_value:Variable, i:number, parameter:Variable)

// closure
// example: \[captured0 captured1] param0 param1 = ...
.decl ClosureVariable(result:Variable, i:number, captured:Variable)
.decl ClosureParameter(result:Variable, i:number, parameter:Variable)

// return value
.decl ReturnValue(n:CodeName, value:Variable)

// instruction ordering
.decl FirstInst(n:CodeName, result:Variable)
.decl NextInst(prev:Variable, next:Variable)

// letrec
.decl RecGroup(first:Variable, v:Variable)

// external
.decl ExternalFunction(f:External, eff:Eff, arity:number)

.input EvalMode
.input Move
.input Node
.input NodeArgument
.input Call
.input CallArgument
.input FunctionParameter
.input Case
.input Alt
.input AltParameter
.input ClosureVariable
.input ClosureParameter
.input ReturnValue
.input FirstInst
.input NextInst
.input RecGroup
.input ExternalFunction

// output

// Reachability
.decl CodeNameInst(n:CodeName, v:Variable)

CodeNameInst(n, v) :-
  FirstInst(n, v).
CodeNameInst(n, v) :-
  CodeNameInst(n, v0),
  NextInst(v0, v).

.output CodeNameInst(delimiter=",")
